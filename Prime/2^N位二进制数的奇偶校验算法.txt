首次说明一下，这个算法是针对位数为2^N的二进制数的。
最近在搞Modbus，要求使用偶检验。想起以前看过一个效率很高的算法，但具体的怎样都想不起来，于是上Google搜索了一轮，终于找到当年看过的算法了：
8位的数据D(D7~D0)，他的算法为：
D ^= D >>4;
D ^= D >>2;
D ^= D >>1;
D&=1;
最后D就是偶校验的值了。
可能有的同学一时之间看不明白算法的原理，这里解释一下吧。
首先从D里面找两个位D1和D0，而D1D0的偶校验值E0=D1^D0，这个大家都明白的，然后D3和D2的检验值E1=D3^D2，同理还有E2=D5^D4以及E3=D7^D6；
E0=1时代表了D1和D0里面有奇数个1，E1、E2和E3同理；
然后复习一下小学数学：奇数*奇数=奇数，偶数*奇数=偶数
如果E0和E1里面有奇数个1，那么D3~D0里面就有奇数数个1，此时D3~D0的偶校验值为1；
“如果E0和E1里面有奇数个1”这句话的意思不就是求由E1和E0组成的两位二进制的偶校验么？而且当E1E0的偶校验值F0=1时，对应的D3~D0的偶校验值也为1。
同理，E3E2的偶校验值F1=1时，对应的D7~D4的偶校验值也为1；
继续同理，由F1和F0组成的两位二进制的偶校验G0=1时，对应的是E3~E0的偶校验值为1，同时对应的D7~D0的偶校验值为1。
于是求D7~D0的偶校验值变成了求F1F0的偶校验值。
那么首先就要将D7~D0的8个位两两分组后在分别求异或，然后再将得出的值的4个位两两分组后分别异或，最后将得出的值的2个位进行异或，得到的值就是D7~D0的偶校验值了。
而分组则不必是相邻的，将D右移4位再和原来的D进行异或的话就简单多了
D7――D3
D6――D2
D5――D1
D4――D0
如此类推，每次先进行右移，然后和原来的值异或，最终就能得到D的校验值了；另外在计算的过程中，仅仅需要关注后面的位数就可以了，如第二次计算时，高4位会有一些数据，到最后高7位也会有数据的，但这些数据都已经没有用了，所以最后只需要来一个&1就可以l。
于是文章开头的那段8位二进制数的算法为：
D ^= D >>4;
D ^= D >>2;
D ^= D >>1;
D&=1;
另外对于2^N位二进制数，第一次右移(2^N)/2位后再异或，然后重复类似的计算N次就可以了。